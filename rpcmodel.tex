\chapter{Исследование моделей использования RPC}
В главе подробно рассматриваются связи между удалёнными компонентами
олимпиадной системы BACS и требования к ним. Разрабатывается
протокол асинхронного RPC на основе системы очередей сообщений.

\section{Синхронные RPC}
Архив задач является одним из важнейших компонентов олимпиадной системы.
Он содержит все задачи, которые используются для проведения соревнований.
Без задач работа системы не имеет смысла.

Задача представляет из себя набор файлов в определённом формате,
Архив предоставляет унифицированный интерфейс доступа к задачам
вне зависимости от формата. Различным частям олимпиадной системы важны
разные компоненты задачи, в частности Web-интерфейсу необходимо запрашивать
метаинформацию: имя задачи, параметры тестирования, авторов. Подобная
информация имеет ряд характерных особенностей:
\begin{itemize}
    \item размер сильно ограничен, обычно до 1 мегабайта;
    \item присутствует у каждой задачи вне зависимости от формата;
    \item в случае обновления необходимо незамедлительно обновлять
        данные Web-интерфейса, выдавать пользователю устаревшие данные
        недопустимо.
\end{itemize}

\subsection{Интерфейс Архива задач}
Интерфейс Архива задач состоит из двух частей. Первая часть это интерфейс
администратора. Он позволяет добавлять, изменять и скачивать задачи.
Вторая часть это запросы, которые обычно инициируются Web-интерфейсом
системы: получение списка всех задач, подробной и краткой информации
об определённых задачах. В обоих случаях важна производительность каждого
запроса. Если же ответ на запрос не может быть доставлен, то необходимости
повторять попытку нет, так как скорее всего данные устарели, по этой причине
персистентность не является требованием.

\subsection{Обоснование gRPC}
При добавлении задачи в архив передаётся большое количество бинарных данных.
Поэтому их кодирование в текстовых представлениях не является эффективным,
XML-RPC или JSON-RPC применять не следует. Выбор был остановлен на gRPC.
Эта реализация RPC позволяет эффективно организовать передачу данных,
а также их хранение без изменения представления при помощи Google Protocol
Buffers.

\section{Асинхронные RPC}
В отличие от запросов к Архиву задач, при тестировании решения особенности
работы существенно отличаются.

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{rs/submit}
    \caption{Решение в системе BACS}
    \label{fig:submit}
\end{figure}

На рисунке~\ref{fig:submit} представлен пример поведения пользователя
и системы при обработке решения. В представленном сценарии пользователь
отправляет в систему решение, которое передаётся Web-интерфейсом
на сервер проверки. Время тестирования решения неизвестно, потому
полезно информировать пользователя о текущем состоянии проверки.
При обновлении страницы пользователь увидит что происходит с его
решением в данный момент времени.

Необходимо иметь ввиду, что пользователей может быть неопределённое количество,
а значит множество решений может находиться на проверке в один момент времени.
Помимо этого, проверка решения может занимать неопределённое время,
обычно до нескольких минут. Выделять на каждого пользователя отдельный
процесс обработки решения в Web-интерфейсе нецелесообразно,
потому применение синхронных RPC не представляется возможным.
Необходима реализация RPC, которая будет контролировать передачу данных
в фоне -- асинхронно, при этом допуская временную недоступность узлов
(Web-интерфейса или сервера проверки), чтобы ресурсоёмкие операции
не приходилось повторять заново, то есть имела свойство персистентности.

В ходе анализа показано, что ни одна из рассмотренных реализаций RPC
не решает проблему персистентности. В данной работе рассматривается
реализация асинхронного персистентного RPC протокола.

\section{Разработка протокола}
\subsection{Требования к протоколу}
Для олимпиадной системы BACS необходимо разработать протокол передачи сообщений,
который будет обладать следующими свойствами:
\begin{itemize}
    \item надёжность и персистентность:
        если запрос не был обработан, в том числе по причине отказа
        принимающей стороны, а также если ответ на запрос временно
        не может быть доставлен, протокол должен повторять попытки;
    \item асинхронность: в один и тот же момент времени может обрабатываться
        неопределённое количество запросов, ответы на них возвращаются
        по мере выполнения запросов (но сохранение порядка неважно);
    \item переносимость: протокол должен иметь возможность быть реализованным
        для различных платформ и языков программирования;
    \item балансировка нагрузки: протокол должен поддерживать дубликацию
        сервисов;
    \item диагностика неисправностей: протокол должен содержать механизм
        для обработки ошибок.
\end{itemize}

Набор требований к RPC позволяет в качестве основы для реализации использовать
систему очередей сообщений. Очередь сообщений позволяет передавать
сообщения между различными компонентами распределённой системы, беря на себя
заботу о сохранности данных и их доставки.

\subsection{Выбор очереди сообщений}
При выборе очереди сообщений важно учитывать популярность и стандартизованность
реализации. При анализе были рассмотрен следующие очереди сообщений.

\textbf{Apache ActiveMQ} -- это брокер сообщений с открытым исходным кодом,
реализующий Java Message Service. Обеспечивает кластеризацию и хранение
сообщений в различных базах данных, кэширование, ведение журналов.

\textbf{Apache Kafka} -- это распределённый брокер сообщений, спроектированный
для высокой масштабируемости.

\textbf{RabbitMQ} -- это платформа, реализующая обмен сообщениями между
компонентами системы на основе протокола AMQP~\cite{amqp}.
Имеет множество библиотек на различных платформах и языках программирования
для доступа к брокеру сообщений: C++, Java, .NET, Perl, Python, Ruby, PHP, Go.
Поддерживает горизонтальное масштабирование.

Выбор был остановлен на RabbitMQ по причине большей
распространённости~\cite{mqcomparison}, использования протокола AMQP,
а значит лучшей гарантии поддержки или простоты замены в будущем брокера
сообщений.

\subsection{Модель RPC}
Протокол RPC строится на основе системы очередей сообщений.
Каждый RPC два основных сообщения: запрос и ответ, а также опциональные
статусные сообщения -- краткие описания текущего состояния.

Протокол RPC делится на два уровня: представление данных и транспортный.
На уровне представления данных передаётся служебная информация, такая как
информация о получателе и отправителе, пользовательский запрос или ответ,
информация об успешности выполнения запроса или ошибки.
Транспортный уровень строится на основе системы очередей сообщений.

В рамках данного протокола как отправитель запроса, так и его получатель
являются клиентами по отношению к брокеру сообщений. Тем не менее
для удобства именования рассматривается весь протокол в целом,
потому отправитель запроса называется клиентом, а получатель -- сервисом.

\subsubsection{Особенности RabbitMQ}
Платформа RabbitMQ обладает рядом особенностей, которые необходимо
учитывать при использовании в качестве транспортного уровня. Правильный
выбор параметров очередей и самих сообщений позволяет добиться высокой
надёжности и эффективности.

Для каждого клиента выделяется две постоянные очереди для получения результатов
и сообщений о критических ошибках. Вторая очередь необходима для тех случаев,
когда передача сообщения об ошибке невозможна посредством первой очереди.
К примеру, если сервис не смог раскодировать запрос из-за ошибки кодирования
или несоответствия формата. В таком случае проблема может быть связана
с несоответствием версий сервиса и клиента, и информация должна быть
передана максимально надёжным способом -- в виде текста без использования
протоколозависимого представления. Подобного рода критические ошибки
не могут быть обработаны протоколом автоматически и предполагается
вмешательство извне для их устранения, к примеру системным администратором.

Особенность постоянных очередей в RabbitMQ является их сохранность при
перезапуске брокера сообщений или его клиента. Сообщение, будучи сохранённым
в очередь, должно быть передано для обработки при первой возможности.
Временная недоступность сети, клиента или самого брокера не должно приводить
к потере сообщения. Каждая из постоянных очередей и сообщений в них
помечаются параметром durable=true, который гарантирует их хранение в постоянной
памяти компьютера. При чтении сообщений из этих очередей используется режим
с подтверждением обработки сообщений noAck=false. После того, как сообщение
было обработано и, к примеру, сохранено в базе данных клиента, брокер
должен получить подтверждение. Только после этого сообщение будет удалено
из очереди навсегда. Если же подтверждение не получено, то после отключения
клиента от брокера сообщение помещается в очередь заново. Это позволяет
не беспокоиться о сохранности сообщений в случае аварийного завершения клиента.

Помимо двух постоянных очередей клиент создаёт временную очередь статусов.
Статус -- это специальное сообщение, которое содержит информацию о текущем
состоянии выполнения запроса.
Характер использования очереди статусов кардинально отличается от использования
постоянных очередей. Здесь в первую очередь важна не сохранность сообщений,
а скорость их доставки. Статус не влияет на логику работы системы и быстро
устаревает. В первую очередь он необходим для пользователя, который хочет
иметь возможность наблюдать состояние выполнения запроса. Можно заметить,
что хранить больше одного состояния смысла нет. Также устаревшие состояния
не имеют смысла, потому очередь, как и все сообщения в ней, помечаются
параметром durable=false, а также для очереди устанавливается параметр
autoDelete=true, который указывает, что брокер будет удалять очередь
при отключении клиента. Попытка доставить сообщение в несуществующую очередь
ведёт к его удалению, что и требуется для временных сообщений.

\subsection{Модель протокола}
\begin{figure}[H]
    \centering
    \input rs/brokerproto.dot
    \caption{Модель протокола}
    \label{fig:brokerproto}
\end{figure}

Протокол предусматривает наличие нескольких сервисов в системе одновременно.
Каждый сервис имеет уникальное имя, но при этом сервис может быть продублирован
для обеспечения надёжность в случае сбоя одной или нескольких его копий.
При сбое необходимо перенаправить все необработанные сообщения на работающие
копии сервиса. Эта задача решается при помощи использования одной постоянной
очереди на сервис. Она создаётся при подключении первой из копий и используется
всеми последующими копиями. При чтении из очереди сообщения распределяются
равномерно между сервисами. Аналогично клиенту, постоянная очередь и все
сообщения, помещаемые в неё помечаются параметром durable=true, а для чтения
сообщений используется режим noAck=false, то есть необходимо подтверждение
обработки сообщения. Так как результатом обработки сообщения является
отправка ответа на него, подтверждать обработку следует только после
помещения ответа в очередь результатов или ошибок. Следует заметить,
что возможен сценарий, при котором сообщение может быть обработано несколько
раз, ответ отправлен несколько раз, но подтверждение обработки запроса
не отправлено. Поэтому задачей клиента является корректная обработка
множественных ответов на один и тот же запрос. Эта проблема является
распространённой в распределённых системах и корректная обработка множественных
ответов или использование идемпотентных запросов, то есть таких, выполнение
которых повторно не приводит к изменению состояния, является повсеместной
практикой~\cite{distributed}.

\subsubsection{Содержание сообщений}
В рамках платформы RabbitMQ сообщение это массив байт с дополнительной
метаинформацией, содержащей параметры хранения сообщения. Так как в протоколе
требуется передача дополнительной информации, к примеру, имена очередей
клиента для ответа, необходим метод кодирования информации в массив байт.
Этот процесс называется сериализацией. Сериализацией в программировании
называют процесс перевода какой-либо структуры данных в последовательность
битов. Процесс восстановления закодированного сообщения из последовательности
битов называется десериализацией.

Для сериализации и десериализации выбрана библиотека Google Protocol Buffers.
Выбор связан с её использованием совместно с gRPC в других частях системы.
Google Protocol Buffers -- включает в себя язык описания структур данных,
которые могут быть сериализованы и десериализованы.

Для удобства изменения структуры разделены на два уровня. Первый уровень это
независимое от RabbitMQ представление данных самих запросов и ответов,
второй же уровень включает вспомогательную информацию, специфичную для RabbitMQ.

Запрос описывается структурой Task (задание), которая содержит название
сервиса worker, имя модуля этого сервиса package, который отвечает
за обработку конкретного типа запроса, а также сам запрос в поле data.

Статус (структура Status) содержит целочисленный код состояния code,
используемый для кодирования типа состояния, краткое описание типа состояния
reason, а также вспомогательная информация data.

Результат (структура Result) содержит тип результата в поле status,
его краткое описание в поле reason, результат работы в поле data
если выполнение запроса завершилось без ошибок (status=OK), и журнал
выполнения запроса в поле log.

Виды состояний результатов:
\begin{itemize}
    \item OK -- выполнение задания прошло успешно;
    \item ERROR -- произошла неизвестная ошибка при выполнении задания;

    \item PROTO\_ERROR -- ошибка связана с обработкой Google Protocol Buffers;

    \item WORKER\_ERROR -- ошибка связана с сервисом;
    \item UNKNOWN\_WORKER -- сервис неизвестен;
    \item INCOMPATIBLE\_PACKAGE -- модуль сервиса несовместим;

    \item PACKAGE\_ERROR -- ошибка модуля сервиса;
    \item PACKAGE\_NOT\_FOUND -- модуль не найден;
    \item PACKAGE\_BUILD\_ERROR -- ошибка инициализации модуля;

    \item EXECUTION\_ERROR -- ошибка выполнения модуля;
    \item EXECUTION\_TIMEOUT -- превышено время выполнения модуля..
\end{itemize}

\lstinputlisting[title="Структуры данных"]{modules/broker/include/bunsan/broker/protocol.proto}

Для передачи описанных выше структур данных используются дополнительные
структуры-обёртки, содержащие служебную информацию для маршрутизации в RabbitMQ.

Для структуры-задания добавляются идентификатор сообщения, дополнительные
ограничения на сервис, а также имена очередей для ответа.

Для структур статуса и результата добавляется только идентификатор сообщения.

\lstinputlisting[title="Структуры данных для RabbitMQ"]{modules/broker/include/bunsan/broker/rabbit/connection.proto}

\section{Выводы}
\begin{enumerate}
    \item Проанализированы синхронные RPC, применяемые при взаимодействии
        Web-интерфейса и Архива задач, построена их модель,
        обоснован выбор gRPC для реализации представленной модели.
    \item Проанализированы асинхронные RPC, применяемые при взаимодействии
        Web-интерфейса и системы тестирования, построена их модель,
        предложен протокол для реализации представленной модели,
        обоснован выбор Google Protocol Buffers и RabbitMQ для реализации
        предложенного протокола.
\end{enumerate}
