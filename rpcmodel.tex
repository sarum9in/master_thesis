\chapter{Исследование моделей использования RPC}
В главе подробно рассматриваются связи между удалёнными компонентами
олимпиадной системы BACS и требования к ним.

% TODO дописать про реализацию протокола (но переформулировать)

% обсуждать проблемы
%  передача переменных, массивов (лишнее)
% пакетный менеджер? (вроде бы лишнее)
% разделить worker и broker

\section{Синхронные RPC}
Архив задач является одним из важнейших компонентов олимпиадной системы.
Он содержит все задачи, которые используются для проведения соревнований.
Без задач работа системы не имеет смысла.

Задача представляет из себя набор файлов в определённом формате,
Архив предоставляет унифицированный интерфейс доступа к задачам
вне зависимости от формата. Различным частям олимпиадной системы важны
разные компоненты задачи, в частности Web-интерфейсу необходимо запрашивать
метаинформацию: имя задачи, параметры тестирования, авторов. Подобная
информация имеет ряд характерных особенностей:
\begin{itemize}
    \item размер сильно ограничен, обычно до 1 мегабайта;
    \item присутствует у каждой задачи вне зависимости от формата;
    \item в случае обновления необходимо незамедлительно обновлять
        данные Web-интерфейса, выдавать пользователю устаревшие данные
        недопустимо.
\end{itemize}

\subsection{Интерфейс Архива задач}
Интерфейс Архива задач состоит из двух частей. Первая часть это интерфейс
администратора. Он позволяет добавлять, изменять и скачивать задачи.
Вторая часть это запросы, которые обычно инициируются Web-интерфейсом
системы: получение списка всех задач, подробной и краткой информации
об определённых задачах. В обоих случаях важна производительность каждого
запроса. Если же ответ на запрос не может быть доставлен, то необходимости
повторять попытку нет, так как скорее всего данные устарели, по этой причине
персистентность не является требованием.

\subsection{Обоснование gRPC}
При добавлении задачи в архив передаётся большое количество бинарных данных.
Поэтому их кодирование в текстовых представлениях не является эффективным,
XML-RPC или JSON-RPC применять не следует. Выбор был остановлен на gRPC.
Эта реализация RPC позволяет эффективно организовать передачу данных,
а также их хранение без изменения представления при помощи Google Protocol
Buffers.

\section{Асинхронные RPC}
В отличие от запросов к Архиву задач, при тестировании решения особенности
работы существенно отличаются.

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{rs/submit}
    \caption{Решение в системе BACS}
    \label{fig:submit}
\end{figure}

На рисунке~\ref{fig:submit} представлен пример поведения пользователя
и системы при обработке решения. В представленном сценарии пользователь
отправляет в систему решение, которое передаётся Web-интерфейсом
на сервер проверки. Время тестирования решения неизвестно, потому
полезно информировать пользователя о текущем состоянии проверки.
При обновлении страницы пользователь увидит что происходит с его
решением в данный момент времени.

Необходимо иметь ввиду, что пользователей может быть неопределённое количество,
а значит множество решений может находиться на проверке в один момент времени.
Помимо этого, проверка решения может занимать неопределённое время,
обычно до нескольких минут. Выделять на каждого пользователя отдельный
процесс обработки решения в Web-интерфейсе нецелесообразно,
потому применение синхронных RPC не представляется возможным.
Необходима реализация RPC, которая будет контролировать передачу данных
в фоне -- асинхронно, при этом допуская временную недоступность узлов
(Web-интерфейса или сервера проверки), чтобы ресурсоёмкие операции
не приходилось повторять заново, то есть имела свойство персистентности.

В ходе анализа показано, что ни одна из рассмотренных реализаций RPC
не решает проблему персистентности. В данной работе рассматривается
реализация асинхронного персистентного RPC протокола.

\section{Разработка протокола}
\subsection{Требования к протоколу}
Для олимпиадной системы BACS необходимо разработать протокол передачи сообщений,
который будет обладать следующими свойствами:
\begin{itemize}
    \item надёжность и персистентность:
        если запрос не был обработан, в том числе по причине отказа
        принимающей стороны, а также если ответ на запрос временно
        не может быть доставлен, протокол должен повторять попытки;
    \item асинхронность: в один и тот же момент времени может обрабатываться
        неопределённое количество запросов, ответы на них возвращаются
        по мере выполнения запросов (но сохранение порядка неважно);
    \item переносимость: протокол должен иметь возможность быть реализованным
        для различных платформ и языков программирования;
    \item диагностика неисправностей: протокол должен содержать механизм
        для обработки ошибок.
\end{itemize}

Набор требований к RPC позволяет в качестве основы для реализации использовать
систему очередей сообщений. Очередь сообщений позволяет передавать
сообщения между различными компонентами распределённой системы, беря на себя
заботу о сохранности данных и их доставки.

\subsection{Выбор очереди сообщений}
При выборе очереди сообщений важно учитывать популярность и стандартизованность
реализации. При анализе были рассмотрен следующие очереди сообщений.

\textbf{Apache ActiveMQ} -- это брокер сообщений с открытым исходным кодом,
реализующий Java Message Service. Обеспечивает кластеризацию и хранение
сообщений в различных базах данных, кэширование, ведение журналов.

\textbf{Apache Kafka} -- это распределённый брокер сообщений, спроектированный
для высокой масштабируемости.

\textbf{RabbitMQ} -- это платформа, реализующая обмен сообщениями между
компонентами системы на основе протокола AMQP~\cite{amqp}.
Имеет множество библиотек на различных платформах и языках программирования
для доступа к брокеру сообщений: C++, Java, .NET, Perl, Python, Ruby, PHP, Go.
Поддерживает горизонтальное масштабирование.

Выбор был остановлен на RabbitMQ по причине большей
распространённости~\cite{mqcomparison}, использования протокола AMQP,
а значит лучшей гарантии поддержки или простоты замены в будущем брокера
сообщений.

\subsection{Модель RPC} % улучшать
Протокол RPC строится на основе системы очередей сообщений.
Каждый RPC два основных сообщения: запрос и ответ, а также опциональные
статусные сообщения -- краткие описания текущего состояния.

Протокол RPC делится на два уровня: представление данных и транспортный.
На уровне представления данных передаётся служебная информация, такая как
информация о получателе и отправителе. Последнее необходимо для того,
чтобы можно было ответить на сообщение.

Пользовательское сообщение не анализируется и передаётся как набор байт адресату.

\subsection{Модель протокола}
\begin{figure}[H]
    \centering
    \input rs/brokerproto.dot
    \caption{Модель протокола}
    \label{fig:brokerproto}
\end{figure}

Отправитель помещает сообщение в очередь заданий, из которой сообщение
извлекается одним из возможных получателей, см. рисунок~\ref{fig:brokerproto}.
Получатель при обработке может посылать промежуточные состояния -- статусы,
для информирования отправителя о ходе обработки задания. По завершении
обработки сообщения получатель помещает результат в очередь заданий
или сообщение об ошибке в очередь ошибок.

Очереди результатов, статусов и ошибок создаются при первичном подключении
каждого отправителя. Очередь заданий создаётся одна на каждый тип задания,
используемый в системе. Создаётся при первичном подключении получателя.

\lstinputlisting{modules/broker/include/bunsan/broker/protocol.proto}

В задании указывается тип получателя, worker. Это может быть использовано
для группировки различных типов серверов, к примеру, с различными операционными
системами. Указывается имя пакета package, это определяет программу, которая
будет запущена для обработки запроса. Последним параметром сообщения являются
данные, которые передаются отправителем -- data.

В статусном сообщении передаются целочисленный код и описание текущего
состояния, а также опционально более подробная информация, связанная с ним.
Это позволяет организовать отображение текущего состояния в пользовательском
интерфейсе в зависимости от типа состояния.

В результирующем сообщении содержится статус, показывающий характер результата.
В случае невозможности установки или запуска процесса обработки это будет
отражено в статусе результата. Во втором поле reason содержится краткое
описание проблемы. В случае если обработка сообщения прошла успешно,
передаётся результат в поле data. Также всегда передаётся лог работы
программы для возможного анализа и устранения неисправностей.

Возможны ситуации, в которых происходит ошибка обработки сообщения-запроса,
к примеру несоответствие формата кодирования сообщения, или аналогичные
проблемы, при которых не имеет смысл возвращать ответ в закодированном виде.
В этих ситуациях используется очередь ошибок, в которую помещается
информация о проблеме в виде текста.

\subsection{Транспортный уровень, очередь сообщений}
Транспортный уровень протокола реализуется при помощи брокера сообщений.
Брокер сообщений создаёт необходимую базу для асинхронного и персистентного RPC.
В качестве промежуточного звена, брокер берёт на себя обязанности хранения
и передачи сообщений в тот момент, когда адресат доступен.

\subsubsection{Очереди сообщений}
Рассмотрим очереди сообщений, применяемые при построении RPC.

\textbf{Очереди заданий, результатов и ошибок} содержат важные для системы
сообщения. Суммарно на каждый RPC запрос создаётся два сообщения
в этих очередях -- количество сообщений линейно зависит от количества RPC.
Важно обеспечить в первую очередь надёжность их передачи.
Сообщения должны сохраняться при перезапуске как сервисов, так и брокера.
Такие очереди создаются с параметром durable=true в соответствии
с AMQP~\cite{amqp}. Аналогично, каждое сообщение, помещаемое в эти очереди,
создаётся с параметром durable=true. Для повышения надёжность используется
подтверждение доставки сообщений. После обработки сообщения и сохранения
ответа на него либо результата сообщение помечается специальным образом.
Очереди создаются с параметром noAck=false, потому если отправитель
или получатель перезапущен, то сообщение возвращается в очередь
брокером автоматически и будет получено повторно.

\textbf{Очередь статусов} используется для передачи временных сообщений текущего
состояния, которые быстро успевают. Такие сообщения важны в первую очередь
для отображения пользователю состояния работы и не влияют на логику работы
системы. Надёжность передачи таких сообщений второстепенна. С другой стороны
скорость передачи крайне важна, так как устаревшее сообщение статуса
теряет смысл. Сохранять сообщения между перезапусками сервисов или брокера
не имеет смысла. Настраивается очередь статусов таким образом, что достигается
максимальная производительность, даже в ущерб надёжности: durable=false,
autoDelete=true, noAck=true.
