\chapter{Разработка RPC на основе брокера сообщений}
В данной главе рассматривается процесс разработки RPC на основе
брокера сообщений RabbitMQ.

\section{Разработка протокола}
Протокол RPC строится на основе системы очередей сообщений.
Каждый RPC два основных сообщения: запрос и ответ, а также опциональные
статусные сообщения -- краткие описания текущего состояния.

Протокол RPC делится на два уровня: представление данных и транспортный.
На уровне представления данных передаётся служебная информация, такая как
информация о получателе и отправителе. Последнее необходимо для того,
чтобы можно было ответить на сообщение.

Пользовательское сообщение не анализируется и передаётся как набор байт адресату.

\subsection{Модель протокола}
\begin{figure}[H]
    \centering
    \input rs/brokerproto.dot
    \caption{Модель протокола}
    \label{fig:brokerproto}
\end{figure}

Отправитель помещает сообщение в очередь заданий, из которой сообщение
извлекается одним из возможных получателей, см. рисунок~\ref{fig:brokerproto}.
Получатель при обработке может посылать промежуточные состояния -- статусы,
для информирования отправителя о ходе обработки задания. По завершении
обработки сообщения получатель помещает результат в очередь заданий
или сообщение об ошибке в очередь ошибок.

Очереди результатов, статусов и ошибок создаются при первичном подключении
каждого отправителя. Очередь заданий создаётся одна на каждый тип задания,
используемый в системе. Создаётся при первичном подключении получателя.

\lstinputlisting{modules/broker/include/bunsan/broker/protocol.proto}

В задании указывается тип получателя, worker. Это может быть использовано
для группировки различных типов серверов, к примеру, с различными операционными
системами. Указывается имя пакета package, это определяет программу, которая
будет запущена для обработки запроса. Последним параметром сообщения являются
данные, которые передаются отправителем -- data.

В статусном сообщении передаются целочисленный код и описание текущего
состояния, а также опционально более подробная информация, связанная с ним.
Это позволяет организовать отображение текущего состояния в пользовательском
интерфейсе в зависимости от типа состояния.

В результирующем сообщении содержится статус, показывающий характер результата.
В случае невозможности установки или запуска процесса обработки это будет
отражено в статусе результата. Во втором поле reason содержится краткое
описание проблемы. В случае если обработка сообщения прошла успешно,
передаётся результат в поле data. Также всегда передаётся лог работы
программы для возможного анализа и устранения неисправностей.

Возможны ситуации, в которых происходит ошибка обработки сообщения-запроса,
к примеру несоответствие формата кодирования сообщения, или аналогичные
проблемы, при которых не имеет смысл возвращать ответ в закодированном виде.
В этих ситуациях используется очередь ошибок, в которую помещается
информация о проблеме в виде текста.

\subsection{Транспортный уровень, очередь сообщений}
Транспортный уровень протокола реализуется при помощи брокера сообщений.
Брокер сообщений создаёт необходимую базу для асинхронного и персистентного RPC.
В качестве промежуточного звена, брокер берёт на себя обязанности хранения
и передачи сообщений в тот момент, когда адресат доступен.

\subsubsection{Выбор брокера сообщений}
Важными требованиями к брокеру сообщений являются:
\begin{itemize}
    \item производительность;
    \item настраиваемость распределения сообщений между адресатами;
    \item кроссплатформенность -- поддержка различных платформ и
        языков программирования;
    \item возможность настройки параметров отдельных очередей и сообщений:
        сохранение очереди и сообщений при перезапуске брокера;
    \item горизонтальная масштабируемость брокера.
\end{itemize}

\textbf{Apache ActiveMQ} -- это брокер сообщений с открытым исходным кодом,
реализующий Java Message Service. Обеспечивает кластеризацию и хранение
сообщений в различных базах данных, кэширование, ведение журналов.

\textbf{Apache Kafka} -- это распределённый брокер сообщений, спроектированный
для высокой масштабируемости.

\textbf{RabbitMQ} -- это платформа, реализующая обмен сообщениями между
компонентами системы на основе протокола AMQP~\cite{amqp}.
Имеет множество библиотек на различных платформах и языках программирования
для доступа к брокеру сообщений: C++, Java, .NET, Perl, Python, Ruby, PHP, Go.
Поддерживает горизонтальное масштабирование.

Выбор был остановлен на RabbitMQ по причине большей распространённости
используемого протокола AMQP, а значит лучшей гарантии поддержки или
простоты замены в будущем брокера сообщений.

\subsubsection{Очереди сообщений}
Рассмотрим очереди сообщений, применяемые при построении RPC.

\textbf{Очереди заданий, результатов и ошибок} содержат важные для системы
сообщения. Суммарно на каждый RPC запрос создаётся два сообщения
в этих очередях -- количество сообщений линейно зависит от количества RPC.
Важно обеспечить в первую очередь надёжность их передачи.
Сообщения должны сохраняться при перезапуске как сервисов, так и брокера.
Такие очереди создаются с параметром durable=true в соответствии
с AMQP~\cite{amqp}. Аналогично, каждое сообщение, помещаемое в эти очереди,
создаётся с параметром durable=true. Для повышения надёжность используется
подтверждение доставки сообщений. После обработки сообщения и сохранения
ответа на него либо результата сообщение помечается специальным образом.
Очереди создаются с параметром noAck=false, потому если отправитель
или получатель перезапущен, то сообщение возвращается в очередь
брокером автоматически и будет получено повторно.

\textbf{Очередь статусов} используется для передачи временных сообщений текущего
состояния, которые быстро успевают. Такие сообщения важны в первую очередь
для отображения пользователю состояния работы и не влияют на логику работы
системы. Надёжность передачи таких сообщений второстепенна. С другой стороны
скорость передачи крайне важна, так как устаревшее сообщение статуса
теряет смысл. Сохранять сообщения между перезапусками сервисов или брокера
не имеет смысла. Настраивается очередь статусов таким образом, что достигается
максимальная производительность, даже в ущерб надёжности: durable=false,
autoDelete=true, noAck=true.

\section{Разработка библиотек}

\subsection{Общая архитектура}
При реализации RPC для конкретных платформ важно придерживаться стиля
программирования, принятого в рамках самой платформы. Тем не менее
можно выделить ряд особенностей, связанных с брокером.

При разработке библиотек выделяется общий компонент -- менеджер подключения.
Он отвечает за установку и восстановление соединения с брокером.
Такая прослойка позволяет упростить логику работы вышестоящих объектов,

На основе менеджера подключения создаются классы отправителя и получателя
сообщений.

\subsection{Особенности Go}
\subsection{Особенности Python}
\subsection{Особенности C\#}
