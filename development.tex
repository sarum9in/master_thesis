\chapter{Разработка RPC на основе брокера сообщений}
В данной главе рассматривается процесс разработки RPC на основе
брокера сообщений RabbitMQ. Оценивается производительность реализованного RPC.

\section{Реализация RPC}

\subsection{Общая архитектура}
При реализации RPC для конкретных платформ важно придерживаться стиля
программирования, принятого в рамках самой платформы. Тем не менее
можно выделить ряд особенностей, связанных с брокером.

Важным достоинством протокола AMQP~\cite{amqp} является его популярность,
и как следствие, существует существенное количество его реализаций.
В работе представлена реализация протокола RPC для трёх платформ Go, Python
и C\#, но в случае реализации протокола для других платформ с императивными
языками программирования рекомендуется придерживаться аналогичной архитектуры.

За основу реализации берётся существующая библиотека AMQP, а также библиотека
Google Protocol Buffers. Используя эти две библиотеки строится логика работы
с подключениями к брокеру, обработка и пересылка сообщений,
см. рисунок~\ref{fig:libbrokercomponents}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{rs/libbrokercomponents}
    \caption{Устройство библиотек}
    \label{fig:libbrokercomponents}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{rs/libbroker}
    \caption{Устройство библиотек}
    \label{fig:libbroker}
\end{figure}

При разработке библиотек выделяется общий компонент -- менеджер подключения.
Он отвечает за установку и восстановление соединения с брокером.
Такая прослойка позволяет упростить логику работы вышестоящих объектов,
На основе менеджера подключения создаются классы отправителя и получателя
сообщений, см. рис.~\ref{fig:libbroker}.

\subsection{Реализация на языке Go}
В качестве библиотеки AMQP используется streadway/amqp~\cite{streadwayamqp}.
Также используется официальная реализация
Google~Protocol~Buffers~\cite{golangprotobuf}.

Исходный код делится на 2 пакета:
\begin{itemize}
    \item \textbf{service} -- обработка запросов и ответов;
    \item \textbf{worker} -- запуск модулей.
\end{itemize}

\subsection{Реализация на языке Python}
В качестве библиотеки AMQP используется pika~\cite{pika}.
Также используется официальная реализация
Google~Protocol~Buffers~\cite{protobuf}.

Исходный код делится на 2 пакета:
\begin{itemize}
    \item \textbf{service} -- обработка запросов и ответов;
    \item \textbf{worker} -- запуск модулей.
\end{itemize}

\subsection{Реализация на языке C\#}
В качестве библиотеки AMQP используется
RabbitMQ~.NET~client~\cite{rabbitmqdotnet}.

Также используется неофициальная реализация
Google~Protocol~Buffers~\cite{protobufnet}. Выбор обусловлен идиоматической
реализацией создания структур данных, что упрощает создание пользовательского
интерфейса библиотеки.

\section{Применение разработанных программных решений}
Разработанный RPC успешно применяется в олимпиадной системе BACS.
Он используется в сервисе тестирования решений для передачи пользовательских
решений в кластер серверов для обработки. Каждое решение тестируется
при помощи специальных модулей, создаваемых автоматически
для каждой имеющейся в системе задачи. Модули генерируются Архивом задач
на основе данных самих задач и помещаются в репозиторий. Сервисы BACS
скачивают модули из репозитория при помощи библиотеки bunsan::pm~\cite{bunsanpm}
и применяют их для тестирования задач. Общая схема работы системы
представлена на рисунке~\ref{fig:bacsservice}.

\begin{figure}[H]
    \centering
    \input rs/bacsservice.dot
    \caption{Сервисы системы BACS}
    \label{fig:bacsservice}
\end{figure}

\subsection{Производительность сервиса тестирования решений}
Основным показателем эффективности сервиса тестирования решений является
его производительность. Она измеряется в среднем количестве проверенных решений
в секунду. Для оценки производительности был проведён эксперимент.
Целью эксперимента является оценка производительности разработанного RPC,
для этого была использована классическая олимпиадная задача "A+B", состоящая
в сложении двух чисел. Время тестирования решений по этой задаче пренебрежимо
мало, меньше 100мс, далее будет показано, что этим можно пренебречь.

В ходе эксперимента было сделано 10000 запросов. Для каждого запроса
было измерено время между отправкой запроса и до получения ответа на него.
На рисунке~\ref{fig:performance} приведена схема распределения времени
выполнения запроса. Среднее время выполнения одного запроса составляет
$\mu = \frac{\sum_{i=1}^N t_i}{N} = 1.975$ секунд, среднеквадратичное отклонение
$\sigma = \sqrt{\frac{\sum_{i=1}^N \left(t_i - \mu\right)^2}{N}} = 0.229$
секунд. Полученная схема соответствует нормальному распределению с параметрами
$\mu = 1.975$ секунд и $\sigma = 0.229$ секунд. Исходя из полученных данных
время проверки решения 0.1 секунды это 5\% от среднего времени работы,
а среднее отклонение 12\%, а значит временем проверки решения можно пренебречь.

\begin{figure}[H]
    \centering
    \includegraphics[width=\columnwidth]{rs/performance}
    \caption{Производительность}
    \label{fig:performance}
\end{figure}

\section{Выводы}
\begin{itemize}
    \item Представлена архитектура реализации созданного во второй главе
        протокола RPC.
    \item Показаны особенности реализации протокола для конкретных платформ:
        Go, Python и C\#.
    \item Представлены результаты оценки производительности RPC. Получены
        численные результаты, произведён их анализ.
\end{itemize}

% vim: spell spelllang=ru
